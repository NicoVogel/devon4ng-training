<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Asynchronous Development</title>

    <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="icon" href="./img/favicon.ico">
    <link rel="stylesheet" href="./reveal.js/css/reveal.css">
    <link rel="stylesheet" href="./reveal.js/css/theme/simple.css">
    <link rel="stylesheet" href="./css/common.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="./css/github-gist.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section class="fullscreen" data-background-size="80rem" data-background-position="0% 100%"
                 data-background-image="./img/Fixed_Shape_5_CapgeminiBlue_RGB.svg">
            <div class="header-bottom-left">
                <h1 class="cap-white">Asynchronous development with Angular</h1>
                <p class="cap-white">Philip Schm√∂kel, Bernd Olleck</p>
            </div>
        </section>
        <section class="fullscreen">
            <h2>What do you know about the JavaScript Eventloop?</h2>
            <div style="display:flex; justify-content: center;padding-top: 4rem">
                <img class="event-loop-scribble" src="./img/event-loop.svg" alt="JavaScript Event Loop">
            </div>
            <ul>
                <li>You know about <span class="cap-blue">Tasks</span> and <span class="cap-blue">Jobs</span>/<span
                        class="cap-blue">Microtasks</span>?
                </li>
            </ul>
            <aside class="notes">
                Some useful links:
                <UL>
                    <LI>
                        https://javascript.info/event-loop
                    </LI>
                    <LI>
                        https://javascript.info/microtask-queue
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>Each thread has its own event loop.</p>
            <ul>
                <li>UI per origin</li>
                <li>web workers</li>
            </ul>
        </section>
        <section>
            <p>Explain the relation between <strong class="cap-blue">Event Loop</strong>, <strong
                    class="cap-blue">Tasks</strong> and <strong class="cap-blue">Microtasks</strong></p>
            <aside class="notes">
                Discuss
                <UL>
                    <LI>
                        Samples of Tasks / Macrotasks
                        <UL>
                            <LI>User events</LI>
                            <LI>Executing the code loaded with a &lt;script src=&quot;...&quot;&gt; tag</LI>
                            <LI>Timeouts which are ready</LI>
                        </UL>
                        Samples of Microtasks
                        <UL>
                            <LI>Promise-Result/Error</LI>
                            <LI>queueMicrotask(...)</LI>
                        </UL>
                    </LI>
                    <LI>Task synonymous with Macrotask, Job with Microtask</LI>
                    <LI>Rendering happens between tasks, not while a task is running</LI>
                    <LI>The microtaskqueue is emptied after the macrotask and before rendering</LI>
                    <LI>How do we create a macrotask / microtask</LI>
                    <LI>How do we display a progress dialog if we do not use Web Workers?</LI>
                    <LI>How do we do something after our current code is finished and the result rendered?</LI>
                </UL>
            </aside>
        </section>
        <section class="fullscreen">
            <h2>What will be the log result?</h2>
            <pre><code class="javascript" data-trim data-line-numbers="">
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
          </code></pre>
        </section>
        <section class="fullscreen">
            <h2>What is a <span class="cap-blue">Tasks</span>?</h2>
            <UL>
                <LI>Examples for tasks are setTimeout, user events, execution of loaded scripts.</LI>
                <LI>The Browser renders changes between tasks.</LI>
                <LI>Tests: tick()</LI>
            </UL>
            <pre><code data-noescape data-trim class="typescript" data-line-numbers="">
import { fakeAsync, tick } from '@angular/core/testing';

it('should set flag to true', fakeAsync(() => {
  let flag = false;
  setTimeout(() => { flag = true; });

  expect(flag).toBeFalsy();

  tick();

  expect(flag).toBeTruthy();
}));
          </code></pre>
        </section>
        <section class="fullscreen">
            <h2>What is a <span class="cap-blue">Microtask</span>?</h2>
            <ul>
                <li>Examples: Results and errors of Promises, queueMicrotask()</li>
                <li>Microtasks are processed after tasks</li>
                <li>Tests: flushMicrotasks()</li>
            </ul>
            <pre><code data-noescape data-trim class="typescript" data-line-numbers="">
  import { fakeAsync, flushMicrotasks } from '@angular/core/testing';
  
  it('should set flag to true', fakeAsync(() => {
    let flag = false;
    Promise.resolve().then(() => { flag = true; });

    expect(flag).toBeFalsy();

    flushMicrotasks();

    expect(flag).toBeTruthy();
  }));
          </code></pre>
        </section>
        <section class="fullscreen">
          <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
button.addEventListener("click", () => {
  console.log("Listener 1");
  
  setTimeout(() => {
    console.log("SetTimeout 1");
  }, 0);
  
  Promise.resolve().then(() => {
    console.log("Promise 1");
  });  
});
button.addEventListener("click", () => {
  console.log("Listener 2");
  
  setTimeout(() => {
    console.log("SetTimeout 2");
  }, 0);

  Promise.resolve().then(() => {
    console.log("Promise 2");
  });
});
          </code></pre>
            <button id="ListenerOrderExampleButton"><h2>What's the correct order?</h2></button>
            <script type="application/javascript">
                {
                    const button = document.getElementById('ListenerOrderExampleButton');
                    button.addEventListener("click", () => {
                        console.log("Listener 1");

                        setTimeout(() => {
                            console.log("SetTimeout 1");
                        }, 0);

                        Promise.resolve().then(() => {
                            console.log("Promise 1");
                        });
                    });
                    button.addEventListener("click", () => {
                        console.log("Listener 2");

                        setTimeout(() => {
                            console.log("SetTimeout 2");
                        }, 0);

                        Promise.resolve().then(() => {
                            console.log("Promise 2");
                        });
                    });
                }
            </script>
        </section>
        <section>
            <section>
                <h2>RxJS - Levelling Up - Basics</h2>
                <ul>
                    <li>Basic Consumption of an Observable
                        <pre><code class="javascript stretch" data-trim>
                            subscription = observable$.subscribe(
                                value => this.doSomethingWith(value));
                            ...
                            subscription.unsubscribe();

                            <span>{{ observable$ | async }}</span>
                        </code></pre>
                        Mind the memory leak - unsubscribe!
                    </li>
                    <li>Basic Creation
                        <pre><code class="javascript stretch" data-trim>
                            of( 1, 2, 3, 4 );
                            from( [ 1, 2, 3, 4 ] );

                            subject$ = new Subject();
                            subject.next('A');
                        </code></pre>
                    </li>
                </ul>
                <aside class="notes">
                    <UL>
                        <LI>of: one parameter after another</LI>
                        <LI>from: values from the array in order, can also take iterator and promise as</LI>
                        <LI>what happens if you give an array to from? You get the complete array as a value.</LI>
                    </UL>
                </aside>
            </section>
            <section>
                <h2>RxJS - Basics: Lifecycle</h2>
                <ul>
                    <li>Parameters of subscribe(...)</li>
                </ul>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                            observable$.subscribe(
                                value => this.doSomethingWith(value),
                                error => this.displayError(error),
                                () => this.weAreDone());

                            observable$.subscribe({
                                next: value => this.doSomethingWith(value),
                                error: error => this.displayError(error),
                                complete: () => this.weAreDone()
                            });
                        </code></pre>
                <ul>
                    <li>And what happens on the source's side</li>
                </ul>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                            subject$ = new Subject();
                            subject.next('A');
                            subject.error('Something went wrong');
                            // or
                            subject.complete();
                        </code></pre>
                <aside class="notes">
                    <UL>
                        <LI>Most observables do not produce values before the first subscribe (possible exception: hot observables)</LI>
                        <LI>Nothing after error or complete</LI>
                    </UL>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 1: Basic Operators</h2>
                <ul>
                    <li>Manipulation and side effects</li>
                </ul>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    observable$.pipe(
                        map( value => value * 2),
                        tap( value => this.doSomething(value))
                    );
                        </code></pre>
                </li>
                <ul>
                    <li>Simple selection and filtering</li>
                </ul>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // Input: 5, 3, 3, 11, 7, 7, 19
                    filter( value => value > 10)  // 11, 19
                    take( 5 )               // 5, 3, 3, 11, 7
                    distinctUntilChanged()  // 5, 3, 11, 7, 19
                        </code></pre>
            </section>
            <section>
                <h2>RxJS - Level 2: Simple Combinations</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline:   1      2  3  4  5  6  7
                    // a$:                a     a     a|
                    // b$:         b b b|
                    // c$:         c         c     c     c|
                    concat( a$, b$, c$)
                    merge( a$, b$, c$)
                </code></pre>
                <aside class="notes">
                    <ul>
                        <LI>concat: all values of the first observable, then the second, then the third</LI>
                        <li>merge: all values when they arrive</li>
                    </ul>
                    solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 2: Simple Combinations (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline:   1        2  3  4  5  6        7
                    // a$:                  a     a     a|
                    // b$:         b b b|
                    // c$:         c           c     c           c|
                    concat( a$, b$, c$)
                    //                      a     a     abbbccc  c|
                    merge( a$, b$, c$)
                    //             b b b c  a  c  a  c  a        c|
                </code></pre>
                <aside class="notes">
                    further questions:
                    <UL>
                        <LI>What happens if b$ emits at timeslot 2?</LI>
                        <LI>What happens if b$ never completes?</LI>
                    </UL>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 3: Value Combinations</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline:   1         2  3  4  5  6  7
                    // a$:                   a1    a2    a3|
                    // b$:         b1 b2 b3|
                    // c$:         c1           c2    c3|
                    forkJoin( a$, b$, c$)
                    combineLatest( a$, b$, c$)
                    zip( a$, b$, c$)
                </code></pre>
                <aside class="notes">
                    <ul>
                        <LI>forkJoin: wait until complete, then emit last values</LI>
                        <li>combineLatest: emit combinations once you have a complete set of values</li>
                        <li>zip: emit tupels of values in order</li>
                    </ul>
                    solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 3: Value Combinations (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline:   1         2      3      4      5      6
                    // a$:                   a1            a2            a3|
                    // b$:         b1 b2 b3|
                    // c$:         c1               c2            c3|
                    forkJoin( a$, b$, c$)
                    //                                                   a3b3c3|
                    combineLatest( a$, b$, c$)
                    //                       a1b3c1 a1b3c2 a2b3c2 a2b3c3 a3b3c3|
                    zip( a$, b$, c$)
                    //                       a1b1c1        2b2bc2        a3b3c3|
                </code></pre>
                <aside class="notes">
                    Further questions:
                    <ul>
                        <li>What happens if b$ emits at timeslot 2?</li>
                        <li>What happens if b$ never completes?</li>
                        <li>What happens if b$ only emits two values?</li>
                        <li>What is a typical usage for forkJoin? (-> do some parallel backend calls)</li>
                        <li>What is a typical usage for combineLatest? (-> something depends on two changing sources)</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 4: Simple Sub Processes</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline:         1  2    3  4  5    6
                    // source:           a       b  c|
                    // inner response:      r:a|       r:c| r:b|
                    switchMap( input => getOneResponse(input))
                    concatMap( input => getOneResponse(input))
                    mergeMap( input => getOneResponse(input))
                </code></pre>
                <aside class="notes">
                    <ul>
                        <LI>switchMap: If you get a new input, ignore the previous result if it is still pending</li>
                        <LI>concatMap: Return values for all inputs in order until inner observable completes, wait if necessary</li>
                        <LI>mergeMap: Return values for all inputs in order of the results</LI>
                    </ul>
                    Solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 4: Simple Sub Processes (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline:         1  2    3  4  5    6
                    // source:           a       b  c|
                    // response a:          r:a|
                    // response b:                          r:b|
                    // response c:                     r:c|
                    switchMap( input => getOneResponse(input))
                    //                      r:a        r:c|
                    concatMap( input => getOneResponse(input))
                    //                      r:a             r:b r:c|
                    mergeMap( input => getOneResponse(input))
                    //                      r:a        r:c  r:b|
                </code></pre>
                <aside class="notes">
                    Followup questions:
                    <ul>
                        <LI>What happens if the inner observable returns multiple values? -> next page</LI>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 5: Complex Sub Processes</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline:         1  2     3        4   5     6     7
                    // source:           a        b        c|
                    // response a:          r:a1               r:a2|
                    // response b:                   r:b1|
                    // response c:                                   r:c1  r:c2|
                    switchMap( input => getResponses(input))
                    concatMap( input => getResponses(input))
                    mergeMap( input => getResponses(input))
                </code></pre>
                <aside class="notes">
                    <ul>
                        <LI>switchMap: If you get a new input, ignore the previous result if it is still pending</li>
                        <LI>concatMap: Return values for all inputs in order until inner observable completes, wait if necessary</li>
                        <LI>mergeMap: Return values for all inputs in order of the results</LI>
                    </ul>
                    Solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 5: Complex Sub Processes (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline:         1  2     3        4   5         6               7
                    // source:           a        b        c|
                    // response a:          r:a1                         r:a2|
                    // response b:                   r:b1|
                    // response c:                             r:c1                      r:c2|
                    switchMap( input => getResponses(input))
                    //                      r:a1     r:b1      r:c1                      r:c2|
                    concatMap( input => getResponses(input))
                    //                      r:a1                         r:a2 r:b1 r:c1  r:c2|
                    mergeMap( input => getResponses(input))
                    //                      r:a1     r:b1      r:c1      r:a2            r:c2|
                </code></pre>
                <aside class="notes">
                    Followup questions:
                    <ul>
                        <LI>What happens if the inner observable does not return a value? (-> timeout, timeoutWith)</LI>
                        <LI>What happens if the inner observable completes late or does not complete?</LI>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 6: Control Timing: Backpressure</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline (ms):   0  100  200  300  400  500  600  700  800  900  1000
                    // source:          a  b    c                        d    e         f
                    delay( 300)
                    debounceTime( 300)
                    sampleTime( 300)
                    throttleTime( 300)
                </code></pre>
                <aside class="notes">
                    Solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 6: Control Timing: Backpressure (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline (ms):   0  100  200  300  400  500  600  700  800  900  1000  1100  1200  1300
                    // source:          a  b    c                        d    e         f
                    delay( 300)
                    //                               a    b    c                        d    e            f
                    debounceTime( 300)
                    //                                         c                                          f
                    sampleTime( 300)
                    //                               c                             e                f
                    throttleTime( 300)
                    //                  a            c                   d              f
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <h2>RxJS - Pattern: unsubscribe using takeUntil</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    class MyComponent implements OnInit, OnDestroy {
                        private onDestroy$ = new Subject();
                        ngOnInit() {
                            interval(1000).pipe(takeUntil(onDestroy$)).subscribe( () => {
                                // do something every second until the component is destroyed
                            });
                        }
                        ngOnDestroy(): void {
                            this.onDestroy$.next();
                            this.onDestroy$.complete();
                        }
                    }
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section class="fullscreen">
            <p>Let's talk about async rxjs</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
const subject = new Subject&lt;boolean&gt;();

const obs = subject.asObservable();
obs.subscribe(v => console.log('next value', v));

console.log('Going to send next value');

subject.next(true);

console.log('Sent next value');
          </code></pre>
            <p>What's happening here? What's the correct order?</p>
            <aside class="notes">
                Sample code is part of the RxJs Examples repository:
                <UL>
                    <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                    <LI>start angular application</LI>
                    <LI>Tab "Training Examples"</LI>
                    <LI>Button "Timing without scheduler"</LI>
                    <LI>Code: TrainingExamplesComponent.startNoScheduler</LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>rxjs Obervable callbacks are not always microtasks!</p>
            <UL>
                <LI>Synchronous execution "when nothing else is required"</LI>
                <LI>Schedulers determine the "something else"</LI>
                <UL>
                    <LI>Microtasks when using asapScheduler</LI>
                    <LI>Macrotasks when using asyncScheduler</LI>
                </UL>
                <LI>Can be controlled with</LI>
                <UL>
                    <LI>observeOn(...)</LI>
                    <LI>subscribeOn(...)</LI>
                    <LI>Implementation of observables and operators</LI>
                </UL>
            </UL>
            <aside class="notes">
                <UL>
                    <LI>
                        https://rxjs.dev/api/operators/observeOn
                    </LI>
                    <LI>
                        https://blog.strongbrew.io/what-are-schedulers-in-rxjs/
                    </LI>
                    <LI>observeOn relates to the steps after it</LI>
                    <LI>subscribeOn to the complete execution</LI>
                    <LI>
                        Schedulers:
                        <UL>
                            <LI>Queue: As synchronously as possible</LI>
                            <LI>Asap: Microtask</LI>
                            <LI>Async: Macrotask</LI>
                            <LI>And some others, e.g. for testing or animation</LI>
                        </UL>
                    </LI>
                    <LI>
                        Some sample code is part of the RxJs Examples repository:
                        <UL>
                            <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                            <LI>start angular application</LI>
                            <LI>Tab "Training Examples"</LI>
                            <LI>Button "Scheduler comparison"</LI>
                            <LI>Code: TrainingExamplesComponent.startSchedulerComparison</LI>
                            <LI>And with a surprise: Button "Microtask vs. Promise", Code TrainingExamplesComponent.startMicrotaskVsPromise</LI>
                        </UL>
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
          <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
const subject = new Subject&lt;boolean&gt;();

const obs = subject.asObservable();
obs.pipe(observeOn(asyncScheduler))
   .subscribe(v => console.log('next value', v));

this.log('Going to send next value');

subject.next(true);

console.log('Sent next value');
          </code></pre>
            <p>What is happening now?</p>
            <aside class="notes">
                Sample code is part of the RxJs Examples repository:
                <UL>
                    <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                    <LI>start angular application</LI>
                    <LI>Tab "Training Examples"</LI>
                    <LI>Button "Timing with asyncScheduler"</LI>
                    <LI>Code: TrainingExamplesComponent.startAsyncScheduler</LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>What's different here?</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
this.httpClient.get('/api/books').subscribe(v => console.log('next value', v));

console.log('after');
          </code></pre>
            <p>Please explain the expected timing in this situation.</p>
            <aside class="notes">
                The important point here is: This is really asynchronous.
                The http response will come "later". And it will still be processed as a Microtask when it arrives...
            </aside>
        </section>
        <section>
            <p>Do you know this?</p>
            <img class="no-border" src="./img/changed-after-checked-exception.png"
                 alt="Angular Exception: Changed after Checked">
            <p>Can you explain what happened?</p>
            <p>What does it have to do with microtasks / macrotasks?</p>
            <aside class="notes">
                <UL>
                    <LI>
                        Hint: Angular change detection runs after a task when the microtask queue is empty.
                    </LI>
                    <LI>
                        https://angular.io/guide/lifecycle-hooks
                    </LI>
                    <LI>
                        Specifically:
                        https://angular.io/guide/lifecycle-hooks#abide-by-the-unidirectional-data-flow-rule
                    </LI>
                    <LI>
                        Detailed explanation:
                        https://indepth.dev/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error/
                    </LI>
                    <LI>
                        Sample code is part of the RxJs Examples repository:
                        <UL>
                            <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                            <LI>start angular application</LI>
                            <LI>Tab "Change Detection Error"</LI>
                            <LI>Button "Activate Child"</LI>
                            <LI>Code: ExpressionChangedExceptionComponent</LI>
                        </UL>
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>How to fix it? What's the better option?</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
/* Promise */
Promise.resolve().then(() => ...bad change...);

/* Timeout */
setTimeout(() => ...bad change...);

/* Change Detector */
...bad change...
this.changeDetectorRef.detectChanges();

/* asyncScheduler */
asyncScheduler.schedule(() => {
  ...bad change...;
});
            </code></pre>
            <aside class="notes">
                <UL>
                    <LI>
                        Best solution is not on the page: Avoid if possible, e.g. by moving to other lifecycle hook or
                        removing the dependency.
                    </LI>
                    <LI>
                        Detailed explanation see
                        https://indepth.dev/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error/
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <h2>Another problem with unit tests and async behaviour</h2>
            <ul>
                <li>ListComponent uses ListService</li>
                <li>ListService.get() returns Observable&lt;Entry[]&gt;</li>
                <li>ListComponent calls get() in ngOnInit()</li>
            </ul>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
  constructor(private service: ListService) {}

  ngOnInit(): void {
    this.service.get().subscribe(res => this.list = res);
  }
          </code></pre>
        </section>
        <section class="fullscreen">
            <h2>Basic unit test</h2>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
describe('ListComponent', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ ListComponent ],
      providers: [{
        provide: ListService,
        useValue: jasmine.createSpyObj('ListService', {
          get: of([{id: 1}])
        })
      }]
    })
  });

  it('loads list', fakeAsync(() => {
    fixture.detectChanges();
    expect(element.querySelectorAll('.list').length).toEqual(1);
  }));
});
          </code></pre>
            <p>What's wrong? Why is this not a good unit test?</p>
            <aside class="notes">
                <UL>
                    <LI>
                        Key: Async behaviour is not tested
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>To focus the problem a little further</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
ngOnInit() {
  this.loading = true;
  this.todosService.get().subscribe(todos => {
    this.todos = todos;
    this.loading = false;
  });
}
          </code></pre>
            <p>How's this code run in test and how in production?</p>
        </section>
        <section class="fullscreen">
            <p>Please explain the fix and why this small change makes all the difference</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="8,15">
describe('ListComponent', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ ListComponent ],
      providers: [{
        provide: ListService,
        useValue: jasmine.createSpyObj('ListService', {
          get: scheduled(of([{id: 1}]), asyncScheduler)
        })
      }]
    })
  });

  it('loads list', fakeAsync(() => {
    tick();
    expect(element.querySelectorAll('.list').length).toEqual(1);
  }));
});
            </code></pre>
        </section>
        <section>
            <h2>Please explain the marble diagram</h2>
            <div style="background-color: rgb(255, 255, 255); box-shadow: rgba(0, 0, 0, 0.17) 0px 1px 2px 1px; border-radius: 2px;">
                <div style="padding: 10px 22px;">
                    <svg viewBox="0 0 7 10" style="width: 48px; height: 68px; overflow: visible;">
                        <line x1="0" x2="112" y1="5" y2="5" style="stroke: black; stroke-width: 0.3;"></line>
                        <polygon points="111.7,6.1 111.7,3.9 114,5"></polygon>
                    </svg>
                    <svg viewBox="0 0 100 10" style="width: 680px; height: 68px; overflow: visible;">
                        <line class="end-marker" x1="100" x2="100" y1="3.2" y2="6.8"
                              style="stroke: black; stroke-width: 0.3; cursor: ew-resize;"></line>
                        <g class="marble" transform="translate(0, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                A
                            </text>
                        </g>
                        <g class="marble" transform="translate(42, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(130, 215, 54); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                B
                            </text>
                        </g>
                        <g class="marble" transform="translate(55, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(255, 105, 70); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                C
                            </text>
                        </g>
                    </svg>
                </div>
                <div style="padding: 10px 22px;">
                    <svg viewBox="0 0 7 10" style="width: 48px; height: 68px; overflow: visible;">
                        <line x1="0" x2="112" y1="5" y2="5" style="stroke: black; stroke-width: 0.3;"></line>
                        <polygon points="111.7,6.1 111.7,3.9 114,5"></polygon>
                    </svg>
                    <svg viewBox="0 0 100 10" style="width: 680px; height: 68px; overflow: visible;">
                        <line class="end-marker" x1="25" x2="25" y1="3.2" y2="6.8"
                              style="stroke: black; stroke-width: 0.3; cursor: ew-resize;"></line>
                        <g class="marble" transform="translate(0, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                1
                            </text>
                        </g>
                        <g class="marble" transform="translate(10, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(130, 215, 54); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                2
                            </text>
                        </g>
                        <g class="marble" transform="translate(20, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(255, 203, 70); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                3
                            </text>
                        </g>
                    </svg>
                </div>
                <div class="operatorBox"
                     style="border: 1px solid rgba(0, 0, 0, 0.06); padding: 22px; text-align: center; position: relative;">
                    <div style="display: block; position: absolute; left: 0px; top: 0px; right: 0px; bottom: 0px; box-shadow: rgba(0, 0, 0, 0.17) 0px 2px 10px 0px;"></div>
                    <span class="operatorLabel"
                          style="font-weight: 400; font-size: 1.3rem; font-family: &quot;Source Code Pro&quot;, monospace;">obs1$.switchMap(() =&gt; obs2$, (x, y) =&gt; "" + x + y)</span>
                    <div style="display: block; position: absolute; left: 0px; top: 0px; right: 0px; bottom: 0px; box-shadow: rgba(0, 0, 0, 0.26) 0px 2px 5px 0px;"></div>
                </div>
                <div style="padding: 10px 22px;">
                    <svg viewBox="0 0 7 10" style="width: 48px; height: 68px; overflow: visible;">
                        <line x1="0" x2="112" y1="5" y2="5" style="stroke: black; stroke-width: 0.3;"></line>
                        <polygon points="111.7,6.1 111.7,3.9 114,5"></polygon>
                    </svg>
                    <svg viewBox="0 0 100 10" style="width: 680px; height: 68px; overflow: visible;">
                        <line class="end-marker" x1="100.01" x2="100.01" y1="3.2" y2="6.8"
                              style="stroke: black; stroke-width: 0.3; cursor: ew-resize;"></line>
                        <g class="marble" transform="translate(0, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                A1
                            </text>
                        </g>
                        <g class="marble" transform="translate(10, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(130, 215, 54); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                A2
                            </text>
                        </g>
                        <g class="marble" transform="translate(20, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(255, 203, 70); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                A3
                            </text>
                        </g>
                        <g class="marble" transform="translate(42, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(255, 105, 70); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                B1
                            </text>
                        </g>
                        <g class="marble" transform="translate(52, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                B2
                            </text>
                        </g>
                        <g class="marble" transform="translate(55.00000000000001, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(255, 203, 70); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                C1
                            </text>
                        </g>
                        <g class="marble" transform="translate(65, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(255, 105, 70); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                C2
                            </text>
                        </g>
                        <g class="marble" transform="translate(75, 5)" style="cursor: default;">
                            <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                            <text text-anchor="middle" y="0.8"
                                  style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                C3
                            </text>
                        </g>
                    </svg>
                </div>
            </div>
            <small>Taken from: https://rxmarbles.com/#switchMap</small>
        </section>
        <section class="fullscreen">
            <h2>Please explain the code</h2>
            <pre><code class="javascript" data-trim data-line-numbers="">
    ngOnInit() {
      this.todo$ = this.route.params.pipe(
        switchMap(params => this.todoService.getTodo(+params['id']))
      )
    }
          </code></pre>
            <p>... and how does it differ to the following?</p>
            <pre><code class="javascript" data-trim data-line-numbers="">
    ngOnInit() {
      this.route.params.subscribe(params => {
        this.todoService.getTodo(+params['id']).subscribe(todo => {
          this.todo = todo;
        });
      });
    }
          </code></pre>
            <p>Which version is better and why?</p>
            <aside class="notes">
                <UL>
                    <LI>
                        Discuss: Observable chains
                    </LI>
                    <LI>
                        Discuss: Subscribe in subscribe
                    </LI>
                </UL>
            </aside>
        </section>
        <section class="fullscreen">
            <h2>Please explain the following code</h2>
            <pre><code class="javascript stretch" data-trim data-line-numbers="">
    import { fromEvent } from 'rxjs';
    import { ajax } from 'rxjs/ajax';
    import { map, filter, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';
      
    const searchInput = document.getElementById('search-box');
      
    const typeahead = fromEvent(searchInput, 'input').pipe(
      map((e: KeyboardEvent) => e.target.value),
      filter(text => text.length > 3),
      debounceTime(150),
      distinctUntilChanged(),
      switchMap(() => ajax('/api/search'))
    );
      
    typeahead.subscribe(data => {
      // handle search result
    });
          </code></pre>
            <p>... what does each operator do exactly? What about the order? Is it important?</p>
            <aside class="notes">
                Some sample code (more complex) is part of the RxJs Examples repository:
                <UL>
                    <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                    <LI>start angular application</LI>
                    <LI>Tab "Search"</LI>
                    <LI>Code: SearchComponent</LI>
                </UL>
            </aside>
        </section>
        <section>
            <h2>How do you find the functions and operators?</h2>
            <ul>
                <li><a href="https://rxjs.dev/guide/operators">Introduction and grouped list of operators (rxjs.dev)</a></li>
                <li><a href="https://rxjs.dev/operator-decision-tree">Operator Decision Tree (rxjs.dev)</a></li>
                <li><a href="http://reactivex.io/documentation/operators.html">Similar information from ReactiveX.io</a></li>
            </ul>
        </section>
        <section>
            <h2>Exercise</h2>
            <ul>
                <li><a href="https://github.com/devonfw-ng-adv-training/rxjs-exercises">Source</a></li>
                <li>
                    Check README.md for information:
                    <ul>
                        <li>Run UnitTests</li>
                        <li>Implement the features. Do not alter the tests.</li>
                    </ul>
                </li>
            </ul>
        </section>
        <section>
            <h2>Resources</h2>
            <ul>
                <li>
                    <a href="http://reactivex.io/rxjs/manual/overview.html">RXJS Docs</a>
                </li>
                <li>
                    <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">HTML Spec: Event
                        Loops</a>
                </li>
                <li>
                    <p><cite>When I told my colleague [...] I was thinking of writing a piece on microtask queueing and
                        execution within the browser's event loop, he said "I'll be honest with you Jake, I'm not going
                        to read that".</cite></p>
                    <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Deep Dive: Blog Post
                        by Chrome Dev. Expert.</a>
                </li>
                <li>
                    <a href="https://netbasal.com/testing-observables-in-angular-a2dbbfaf5329">Blog Article: Testing
                        Observables in Angular</a>
                </li>
            </ul>
        </section>
    </div>
</div>

<script src="./reveal.js/js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        width: '100%',
        height: '100%',
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {
                src: './reveal.js/lib/js/classList.js', condition: function () {
                    return !document.body.classList;
                }
            },
            {
                src: './reveal.js/plugin/markdown/marked.js', condition: function () {
                    return !!document.querySelector('[data-markdown]');
                }
            },
            {
                src: './reveal.js/plugin/markdown/markdown.js', condition: function () {
                    return !!document.querySelector('[data-markdown]');
                }
            },
            {
                src: './reveal.js/plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            },
            {src: './reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: './reveal.js/plugin/notes/notes.js', async: true}
        ]
    });
</script>
</body>
</html>
