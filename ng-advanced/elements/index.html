<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Microfrontends</title>

    <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="icon" href="./img/favicon.ico">
    <link rel="stylesheet" href="./reveal.js/css/reveal.css">
    <link rel="stylesheet" href="./reveal.js/css/theme/simple.css">
    <link rel="stylesheet" href="./css/common.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="./css/github-gist.css">
</head>

<body>
    <div class="reveal">
        <section class="slides">
            <section class="fullscreen" data-background="url(./img/Fixed_Shape_3_CapgeminiBlue_RGB.svg) no-repeat 0 500px, url(./img/raindrops.jpg)">
                <div class="header-bottom-left">
                    <h1 class="cap-white">Microfrontends</h1>
                    <p class="cap-white">Philip Schmökel, Bernd Olleck</p>
                </div>
            </section>
            <section class="fullscreen">
                <section>
                    <h2 class="header-left">Microfrontends - what does that mean?</h2>
                    <ul>
                        <li>Split your UI into parts that can be developed independently
                            <img src="./img/Amazon-Split.PNG" alt="a microfrontend split example" width="1000px" class="no-border">
                            <p><small>Background image taken from <a href="http://amazon.com">amazon.com</a> in April
                            2019</small>
                            </p>
                        </li>
                    </ul>
                    <aside class="notes">
                        <UL>
                            <LI>
                                Note: This image does not imply that Amazon uses a microfrontend with this split. It is only a good example how a split could be done.
                            </LI>
                            <LI>
                                This is nothing new! Tagline: Well, where I’m from, we called that Dialogs and UI Components, more than 10 years ago…
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section class="fullscreen">
                    <h2 class="header-left">Microfrontends - New Constraints - New Reasons</h2>
                    <UL>
                        <LI>Time to Market!</LI>
                        <UL>
                            <LI>Faster change speed because of smaller scope</LI>
                            <LI>Individual deployments of parts</LI>
                        </UL>
                        <LI>Technology: Web Components</LI>
                        <LI>Long term cost reduction</LI>
                        <UL>
                            <LI>Better code/architecture through enforced splits</LI>
                        </UL>
                        <LI>Multi supplier integration in one application</LI>
                        <LI>Most other reasons for Microservices (backend) apply: Replacabilty, encapsulated domain, independent deployment
                        </LI>
                    </UL>
                </section>
                <section class="fullscreen">
                    <h2 class="header-left">Reasons for not doing Microfrontends</h2>
                    <ul>
                        <LI>Politics a.k.a. Lemmings: everybody else is doing it!</LI>
                        <UL>
                            <LI>“Everybody else” typically has different use cases!</LI>
                        </UL>
                        <LI>Short term cost reduction</LI>
                        <UL>
                            <LI>The opposite will happen!</LI>
                        </UL>
                        <p><br/></p>
                        <A href="https://www.thoughtworks.com/radar/techniques/micro-frontends">Technology Radar: Adopt
                        (April 2019)</A>
                    </ul>
                </section>
                <section>
                    <h2 class="header-left">Categorization: Functional - Portal</h2>
                    <ul style="width: 27%; float:left; ">
                        <li>Loosely coupled applications</li>
                        <li>Minimal shared state</li>
                        <li>Common menu/navigation system</li>
                        <li>Common user context</li>
                        <li>Typical example: Internal web workplaces</li>
                    </ul>
                    <img src="./img/microfrontend-category-portal.PNG" alt="example for a 'portal'" style="width:67%; float: right; " class="no-border">
                    <aside class="notes">
                        <UL>
                            <LI>
                                Note: The names of the categories "portal" - "portlet" - "integrated" are not really defined but my own characterization.
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section>
                    <h2 class="header-left">Categorization: Functional - Portlet</h2>
                    <ul style="width: 27%; float:left; ">
                        <li>Parts of an application</li>
                        <li>Integrated display</li>
                        <li>Some shared state</li>
                        <li>Little data integration</li>
                        <li>Typical example: The shopping world</li>
                    </ul>
                    <img src="./img/microfrontend-category-portlet.PNG" alt="example for a 'portlet'" style="width:67%; float: right; " class="no-border">
                    <aside class="notes">
                        <UL>
                            <LI>
                                Note: The names of the categories "portal" - "portlet" - "integrated" are not really defined but my own characterization.
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section>
                    <h2 class="header-left">Categorization: Functional - Integrated</h2>
                    <div>
                        <ul style="width: 27%; float:left; ">
                            <li>Functional Parts of Dialogs</li>
                            <li>Integrated display</li>
                            <li>Integrated state</li>
                            <li>Integrated data</li>
                            <li>Example: Editing a complex business object</li>
                        </ul>
                        <img src="./img/microfrontend-category-integrated.PNG" alt="example for a 'integrated' microfrontend" style="width:67%; float: right; " class="no-border">
                    </div>
                    <div style="clear:both;"></div>
                    Always consider the API!
                    <aside class="notes">
                        <UL>
                            <LI>
                                Note: The names of the categories "portal" - "portlet" - "integrated" are not really defined but my own characterization.
                            </LI>
                            <LI>
                                Think:
                                <br/> When splitting, always consider the API! That can be the difference between success and failure!
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section>
                    <h2 class="header-left">Categorization: Backend Integration</h2>
                    What is the relationship between<br/> Microfrontend Component and Microservice Backend?
                    <img src="./img/microfrontend-integration-behaviour.PNG" alt="integration behaviour" style="width:90%;" class="no-border">
                    <aside class="notes">
                        <UL>
                            <LI>
                                Tagline: Mix and match!
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section>
                    <h2 class="header-left">Team Structure</h2>
                    <img src="./img/microfrontend-team-structure.PNG" alt="integration behaviour" style="width:90%;" class="no-border">
                    <p><small>Source: <a href="https://micro-frontends.org/">https://micro-frontends.org/</a> April
                    2019</small>
                    </p>
                    <aside class="notes">
                        <UL>
                            <LI>
                                Tagline: Developers of the Full Stack! Masters of Nothing!
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section>
                    <h2 class="header-left">Microfrontend Technology Flowchart</h2>
                    <img src="./img/microfrontend-technology-flowchart.PNG" alt="integration behaviour" style="width:90%;" class="no-border">
                    <p><small>Source: <a href="www.softwarearchitekt.at">www.softwarearchitekt.at</a> April 2019</small>
                    </p>
                    <aside class="notes">
                        <UL>
                            <LI>
                                Note: Reusing code - no matter how - helps!
                            </LI>
                            <LI>
                                There is also the option to use server based technology, e.g. (old) server side includes (but javascript is not merged easily, or Zalando's "Project Mosaic"
                            </LI>
                            <LI>
                                Concerning iframes: For integrating legacy apps or apps with incompatible frameworks. Iframe isolation can be overcome by postMessage(...), deep linking is possible with some work.
                            </LI>
                            <LI>
                                Followup: Spotlight on Deployment Monolith, and then on to "Web Components".
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section>
                    <h2 class="header-left">Majestic Deployment Monolith</h2>
                    Idea: Build functional components separately (npm modules),
                    <br/>join them in a shell application
                    <img src="./img/microfrontend-deployment-monolith.jpg" alt="deployment monolith module structure" style="width:70%;" class="no-border">
                    <aside class="notes">
                        <UL>
                            <LI>
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section>
                    <h2 class="header-left">Majestic Deployment Monolith</h2>
                    <ul>
                        <li>Separate development, build and test is possible</li>
                        <ul>
                            <li>E.g. using Stub-Applications</li>
                        </ul>
                        <li>Works well if the same framework is used</li>
                        <ul>
                            <li>But 3rd party library versions should be synchronized</li>
                        </ul>
                        <li>Joint application build can use framework features<br/>(e.g. tree shaking, lazy loading)</li>
                        <ul>
                            <li>Build may take considerable time</li>
                        </ul>
                        <li>Independent deployment not possible</li>
                        <ul>
                            <li>But with a good build infrastructure you almost get there</li>
                        </ul>
                        <li>API: Everything you want, even type safe (with api library projects)</li>
                    </ul>
                    <aside class="notes">
                        <UL>
                            <LI>
                            </LI>
                        </UL>
                    </aside>
                </section>
            </section>
            <section class="fullscreen">
                <h2 class="header-left">WebComponents</h2>
                <p class="cap-blue"></p>
                <img src="./img/support.png" alt="supported browsers" style="width:85%;" class="no-border">
                <p><small>taken from <a href="https://www.webcomponents.org">webcomponents.org</a> in September 2020</small>
                </p>
                <aside class="notes">
                    <UL>
                        <LI>
                            Web Component standard actually means 4 different things.
                        </LI>
                        <LI>
                            Note: IE is not mentioned! There are two different polyfills to make custom elements work with IE 11: One offers incomplete functionality and the other one has a serious performance impact.
                        </LI>
                    </UL>
                </aside>
            </section>
            <section class="fullscreen">
                <h2 class="header-left">Template</h2>
                <pre><code data-trim class="html">&lt;template id="template"&gt;
  &lt;p style="font-size: 5rem"&gt;Do you remember handlebars.js?&lt;/p&gt;
&lt;/template&gt;</code></pre>
                <ul>
                    <li>declare fragments of HTML that can be cloned and inserted in the document by script</li>
                    <li>
                        Try out by pasting this in Chrome dev console
                        <pre><code data-trim class="js">
document.querySelector('section.present').appendChild(
  document.querySelector('#template').content.cloneNode(true)
)
          </code></pre>
                    </li>
                </ul>
                <template id="template"><p style="font-size: 5rem">Do you remember handlebars.js?</p></template>
                <aside class="notes">
                    <UL>
                        <LI>
                            Tag name: template, content is not a child, but read only accessible by DOM attribute "content".
                        </LI>
                        <LI>
                            Content is not displayed, only parsed to check for correctness
                        </LI>
                        <LI>
                            Placeholders are not supported (opposed to what "templating" suggests). But there is another tag 'slot'. And in combination with custom elements that allows for a great templating mechanism.
                        </LI>
                        <LI>
                            Difference cloneNode / importNode: owner document is the same / where it is imported
                        </LI>
                        <LI>
                            Info: Handlebars = Mustache - an "old" web templating system https://en.wikipedia.org/wiki/Mustache_(template_system)
                        </LI>
                    </UL>
                </aside>

            </section>
            <section>
                <section class="fullscreen">
                    <h2 class="header-left">Custom Elements</h2>
                    <pre><code data-trim class="js">
    class HelloParagraph extends HTMLElement {
      constructor() {
        super();
        this._firstname = 'Otto';
      }

      static get observedAttributes() { return ["firstname"]; }

      attributeChangedCallback(name, oldValue, newValue) {
        this._firstname = newValue;
        this.render();
      }

      connectedCallback() {
        this.render();
      }

      render() {
        this.innerHTML = `&lt;p&gt;Hello ${this._firstname}!&lt;/p&gt;`;
      }
    }
    customElements.define('hello-paragraph', HelloParagraph);
          </code></pre>
                    <ul>
                        <li>Provide a way for authors to build their own fully-featured DOM elements.</li>
                        <li>
                            Try out by pasting this in Chrome dev console
                            <pre><code class="js" data-trim>
    document.querySelector('section.present').appendChild(
      document.createElement('hello-paragraph')
    )
    document.querySelector('hello-paragraph').setAttribute('firstname', 'Karl');
                    </code></pre>
                        </li>
                    </ul>
                    <aside class="notes">
                        <UL>
                            <LI>
                                Source code is in js/hello-paragraph.js (reused with modules example below)
                            </LI>
                            <LI>
                                Types:
                                <UL>
                                    <LI>Autonomous: derive from HTMLElement, use with custom tag name</LI>
                                    <LI>Customized build in: derive from desired (e.g. HTMLParagraphElement), use with original tag name and is="custom-tag-name"
                                    </LI>
                                </UL>
                            </LI>
                            <LI>
                                Register using "customElements.define(&lt;new-tag-name"&gt;, &lt;class-name&gt;)".
                            </LI>
                            <LI>
                                Required: custom element tag names must have a dash '-'
                            </LI>
                            <LI>
                                Lifecycle callbacks:
                                <UL>
                                    <LI>connectedCallback: when added to or moved in the DOM</LI>
                                    <LI>disconnectedCallback: when removed from DOM</LI>
                                    <LI>adoptedCallback: when moved to new document</LI>
                                    <LI>attributeChangedCallback: when a declared attribute is changed</LI>
                                    <LI>static get observedAttributes: declaring the attributes we're interested in</LI>
                                </UL>
                            </LI>
                            <LI>
                                Show what is happening in the DOM when executing the code
                                <UL>
                                    <LI>Node hello-paragraph with its own properties (_firstname)</LI>
                                    <LI>Child structure visible</LI>
                                </UL>
                            </LI>
                        </UL>
                    </aside>
                </section>
                <section class="fullscreen">
                    <h2 class="header-left">Custom Elements Pitfalls</h2>
                    <UL>
                        <LI>JavaScript scope is still global!</LI>
                        <LI>Some other things are also still shared:</LI>
                        <UL>
                            <LI>window. &amp; document.</LI>
                            <LI>Progressive Web APIs, e.g. local storage</LI>
                            <LI>Namespace of custom elements</LI>
                        </UL>
                        <LI>...?</LI>
                    </UL>
                    <aside class="notes">
                        <UL>
                            <LI>
                                There may be other pitfalls - this is relatively new technology...
                            </LI>
                        </UL>
                    </aside>
                </section>
            </section>
            <section>
                <section class="fullscreen">
                    <h2 class="header-left">Shadow Dom</h2>
                    <img width="700px" src="./img/shadow-dom.png" alt="Shadowdom explained" class="no-border">
                    <p><small>taken from <a
                        href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">developer.mozilla.org/</a>
                    in August 2019</small></p>
                    <pre><code class="js" data-trim>
let shadow = elementRef.attachShadow({mode: 'open'});
let shadow = elementRef.attachShadow({mode: 'closed'});
      </code></pre>
                    <ul>
                        <li>Property <code>mode</code> controls whether or not the shadow tree can be accessed by JavaScript from outside.
                        </li>
                    </ul>
                </section>
                <section>
                    <h2 class="header-left">Shadow Dom Example</h2>
                    <style>
                        /* global style definitions */
                        
                        .ClassOfDiv {
                            background-color: lightblue;
                        }
                    </style>
                    <div>
                        <div id="outside">
                            <h1>H1 in DIV inside the page</h1>
                        </div>
                        <div id="inside" ">
                    <h1>H1 in DIV inside the page - this will be replaced by shadow</h1>
                </div>
</div>
<pre><code class="js " data-trim>
function createDivWithP() {
    var div = document.createElement('div');
    div.classList.add('ClassOfDiv');
    div.innerHTML = 'text in div'
        + '<p>text in p</p>';
    return div;
}
// add child without shadow dom
document.getElementById('outside').appendChild(createDivWithP());
// add child with shadow dom
var inside = document.getElementById('inside');
var insideShadow = inside.attachShadow({mode: 'open'});
insideShadow.innerHTML = '<h1>Inside the shadow</h1>';
insideShadow.appendChild(createDivWithP());
var styleInsideShadow = document.createElement('style');
styleInsideShadow.textContent =
      '.ClassOfDiv {'
    + '   color: red;'
    + '}'
    + 'body {'
    + '   background-color:red;'
    + '}';
insideShadow.appendChild(styleInsideShadow);
      </code></pre>
<aside class="notes ">
    <UL>
        <LI>
            Show the example step by step, show what happens in the DOM tree.
        </LI>
        <LI>
            Initially point out the setup:
            <UL>
                <LI>Two DIV with H1 inside. First has class 'outside', second has class 'inside'.</LI>
                <LI>Helper function that creates a DIV with 'ClassOfDiv' and a text and a P with another test</LI>
                <LI>CSS Style is configured for 'ClassOfDiv' with background color</LI>
            </UL>
        </LI>
        <LI>
            When adding the child to the 'outside': H1 remains, background is colored as expected.
        </LI>
        <LI>
            When attachShadow: H1 disappears.<br/>
            Show DOM!
        </LI>
        <LI>
            When defining content of shadow: H1 with new text appears
            Show DOM!
        </LI>
        <LI>
            When appending the child: it is not affected by the background of 'ClassOfDiv'
        </LI>
        <LI>
            When defining styles for the shadow dom:
            <UL>
                <LI>text color does not affect outside</LI>
                <LI>body does not affect anything</LI>
            </UL>
        </LI>
        <LI>
            Demonstrate the leaks of 'inheritable attributes':
            Define style="background:green; color:white " on the parent div.
            Background changes because it is transparent by default, but text color changes because it is inheritable.
            <br/>
            And then add the style ':host { all:initial; }' to the shadow's style.
            Observe that other things now look strange, because font side, has been reset as well...
        </LI>
        <LI>
            Show what happens when you select divs with '.ClassOfDiv' in Javascript,
            and demonstrate how to get the nodes of the open shadow root.
        </LI>
        <LI>
            Demonstrate the same thing with closed shadow.
            Difference: shadowRoot is null
        </LI>
    </UL>
</aside>
</section>
<section class="fullscreen ">
    <h2 class="header-left ">Shadow Dom Pitfalls</h2>
    <UL>
        <LI>There are some features ... or are they bugs?</LI>
        <UL>
            <LI>Fonts are global</LI>
            <LI>'inheritable styles' leak - reset with 'all: initial' may be good.</LI>
        </UL>
        <LI>Automated UI-Testing: Find Elements</LI>
        <UL>
            <LI>
                Open Shadow: You need to combine queries with the 'shadowRoot' in between.
            </LI>
            <LI>
                Closed Shadow: You're out of luck (unless you can hack something)
            </LI>
        </UL>
    </UL>
</section>
</section>
<section class="fullscreen ">
    <h2 class="header-left ">Combine Custom Elements and Shadow Dom</h2>
    <pre><code class="js " data-trim>
customElements.define('hello-paragraph', class extends HTMLElement {
  constructor() {
    super();

    const shadowRoot = this.attachShadow({mode: 'open'});
    shadowRoot.innerHTML = `
      &lt;style&gt;...&lt;/style&gt;
      &lt;div id="tabs "&gt;...&lt;/div&gt;
      &lt;div id="panels "&gt;...&lt;/div&gt;
    `;
  }
  ...
});
      </code></pre>
</section>
<section class="fullscreen ">
    <h2 class="header-left ">ES Modules are finally implemented</h2>
    <pre><code class="html " data-trim>
  &lt;!-- index.html --&gt;
  &lt;hello-paragraph&gt;&lt;/hello-paragraph&gt;
  &lt;script src="main.js " type="module "&gt;&lt;/script&gt;
      </code></pre>
    <pre><code data-trim class="js ">
// main.js
import {HelloParagraph} from './hello-paragraph.js';

customElements.define('hello-paragraph', HelloParagraph);
      </code></pre>
    <pre><code data-trim class="js ">
// hello-paragraph.js
export class HelloParagraph extends HTMLElement {
  // ...
}         
      </code></pre>
    <ul>
        <li>This is what we did to showcase CustomElements a few slides back.</li>
    </ul>
    <aside class="notes ">
        <UL>
            <LI>
                Modules introduce a top level scope:
                <UL>
                    <LI>var xyz = 17 does not set window.xyz</LI>
                    <LI>this is not window</LI>
                    <LI>Imports/export work like you know from typescript</LI>
                </UL>
            </LI>
            <LI>
                This has the potential to replace bundlers like webpack
                <UL>
                    <LI>But they provide other advantages like tree shaking...</LI>
                </UL>
            </LI>
            <LI>Important effect: the module type ensures that the browser has a minimum level of language:
                no old legacy code needed in modules
            </LI>
        </UL>
    </aside>
</section>
<section>
    <section class="fullscreen " data-background="url(./img/ng-elements-intro.png) ">
        <div class="header-bottom-left message-sum ">
            <p>With Angular 6 project <strong>Angular Elements</strong> has been shipped.</p>
        </div>
    </section>
    <section class="fullscreen ">
        <h2 class="header-left ">Angular Elements compiles Angular components as CustomElements.</h2>
        <pre style="margin: auto; "><code class="ts " data-trim>
@Component({
    selector: 'app-root',
    template: `<h1>Some Component Stuff</h1>`,
})
export class AppComponent {
    constructor(injector: Injector, public popup: PopupService) {
        // Convert `PopupComponent` to a custom element.
        const PopupElement = createCustomElement(PopupComponent, {injector});
        // Register the custom element with the browser.
        customElements.define('popup-element', PopupElement);
    }
}
      </code></pre>
    </section>
    <section class="fullscreen ">
        <h2 class="header-left ">Why do we need this?</h2>
        <ul>
            <li class="fragment ">Move closer to HTML standards</li>
            <li class="fragment ">Integrate with different technologies</li>
            <li class="fragment ">Go for Microfrontend application landscapes</li>
            <li class="fragment ">Enable Lazy Migrations</li>
            <li class="fragment ">Develop Design Systems</li>
            <li class="fragment ">Make Angular easier. Hardest concepts are Angular Modules, rxjs and zone.js. In the
                future, Angular Elements will work without them all.
            </li>
        </ul>
    </section>
</section>
<section>
    <section data-background="linear-gradient(to bottom right, #0070AD, rgb(18,171,219)) ">
        <h2 class="cap-white ">Exercise Time</h2>
    </section>
    <section class="fullscreen ">
        <h2 class="header-left ">Pitfalls (1)</h2>
        <ul>
            <li>
                "Bleeding Edge " Technology
                <UL>
                    <LI>There may be issues in Angular</LI>
                    <LI>Some things are subject to change (but then that's generally the case with Angular)</LI>
                    <LI>And we do not have a lot of experience yet in the scope of enterprise applications</LI>
                </UL>
            </li>
            <li>
                Caching of your sources
                <UL>
                    <LI>For build purposes we strip the hash - but that hurts with caching</LI>
                </UL>
            </li>
        </ul>
    </section>
    <section class="fullscreen ">
        <h2 class="header-left ">Pitfalls (2)</h2>
        <ul>
            <LI>
                Services
                <UL>
                    <LI>
                        Services are not shared with host application - extra work necessary
                    </LI>
                    <LI>
                        Global service lifetime - may keep obsolete stuff in memory
                    </LI>
                    <LI>
                        Zone.js should be shared when running separate webcomponents in Angular with shared services
                    </LI>
                    <LI>
                        or even be without zone.js...
                    </LI>
                </UL>
            </LI>
            <LI>
                Some browser features are not scoped or behave 'interestingly'<br>
                (progressive web APIs, shadow dom leaks)
            </LI>
            <LI>
                Angular build result must be scoped (e.g. using ngx-build-plus)
            </LI>
            <LI>
                Namespacing of custom elements
            </LI>
            <LI>
                Angular Elements only support @Input and @Output, no public method calls.
                Workaround needed like element.ngElementStrategy.componentRef.instance.yourMethod().
            </LI>
        </ul>
        <aside class="notes ">
            <UL>
                <LI>
                    Zone.js: https://medium.com/@tomastrajan/the-best-way-to-lazy-load-angular-elements-97a51a5c2007
                </LI>
            </UL>
        </aside>
    </section>
    <section class="fullscreen ">
        <h2 class="header-left ">Pitfalls (3)</h2>
        <ul>
            <LI>
                E2E-Testing requires some adjustments with shadow dom
            </LI>
            <LI>
                @Input data may not be filled before first lifecycle calls, so use ?. (or if ...)
            </LI>
            <LI>
                @Output event data is wrapped in the browser's custom event
                <UL>
                    <LI>
                        access data using $event.detail
                    </LI>
                    <LI>
                        be wary of unexpected type changes.
                    </LI>
                </UL>
            </LI>
        </ul>
    </section>
</section>
<!-- <section>
    <section>
        <p>With Angular 8 <strong>Ivy Compiler</strong> has been shipped.</p>
        <p>It's a compiler, why should I care?</p>
    </section>
    <section class="fullscreen ">
        <p style="text-align: left " class="cap-blue ">Flashback</p>
        <ul>
            <li>
                <p>How does Angular compilation work?</p>
                <fake-console prompts='["ng build [--aot] ", "ng serve [--aot] "]'></fake-console>
            </li>
            <li>
                <p>How does Angular bootstrap work?</p>
                <pre><code class="ts " data-trim>
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic'
import {AppModule} from './app.module';

platformBrowserDynamic().bootstrapModule(AppModule);
          </code></pre>
            </li>
            <li>
                <p>Is this compatible with the idea of small CustomElements loaded asynchronously into the
                    browser?</p>
                <pre><code class="html " data-trim>
&lt;!-- this is what we want. --&gt;
&lt;hello-paragraph&gt;&lt;/hello-paragraph&gt;
&lt;script src="main.js " type="module "&gt;&lt;/script&gt;
          </code></pre>
            </li>
        </ul>
        <aside class="notes ">
            <UL>
                <LI>
                    Compile: During development the code is compiled in the browser at runtime (JIT = just in time).
                    For deployments (prod-builds), the code is compiled before (AOT = ahead of time).
                    <br/>
                    Compilation steps: typescript compilation + code analysis + code generation
                </LI>
                <LI>
                    Build result contains angular framework - can be large
                </LI>
            </UL>
        </aside>
    </section>
    <section class="fullscreen ">
        <h2 class="header-left ">Bootstrap Angular Elements with Ivy</h2>
        <pre><code style="max-height: 600px; " data-trim class="ts ">
import {ɵrenderComponent as renderComponent, ɵdetectChanges as detectChanges} from '@angular/core';
import {SayHelloComponent} from './say-hello.component';

class SayHelloElement extends HTMLElement {
  component: SayHelloComponent;

  constructor(){
    super();
    this.component = renderComponent(SayHelloComponent, {host: this}); // no modules
  }

  set name(v){
    this.component.name = v;
    detectChanges(this.component); // no zone.js, no ChangeDetectorRef, just a function
  }
  // ...
}

customElements.define('say-hello', SayHelloElement);
      </code></pre>
        <p><small>It's in the early stage and there is still heavy development going on. ɵ means private.</small>
        </p>
    </section>
    <section class="fullscreen ">
        <h2 class="header-left ">Possible bootstrap with Ivy in Angular 9+</h2>
        <pre><code class="ts " data-trim>
import {withNgComponent} from '@angular/elements';
import {SayHelloComponent} from './say-hello.component';

const SayHelloElement = withNgComponent(SayHelloComponent);

customElements.define('say-hello', SayHelloElement);
      </code></pre>
        <p><small>shown at ng-conf in <a href="https://www.youtube.com/watch?v=JX5GGu_7JKc ">Not Every App is a SPA |
            Rob Wormald</a></small></p>
        <p><code>withNgComponent()</code> is a higher order component. Finally coming to Angular.</p>
    </section>
    <section class="fullscreen ">
        <h2 class="header-left ">Modules</h2>
        <pre><code class="ts " data-trim>
import {NgElement, withNgElement} from '@angular/elements';
import {SomeService} from 'some-lib'
import {SomeDirective, SomePipe} from 'some-lib';

@NgElement({
  selector: 'say-hello',
  template: '...',
  providers: [SomeService]
  deps: [SomeDirective, SomePipe]
})
class SayHelloComponent extends withNgElement() {}
      </code></pre>
        <p>Remember Angular 2.0.0-rc.4?</p>
        <aside class="notes ">
            <UL>
                <LI>
                    Apparently this is similar to Angular 2.0.0-rc.4 before Angular Modules were introduced...
                </LI>
            </UL>
        </aside>
    </section>
    <section data-background="linear-gradient(to bottom right, #0070AD, rgb(18,171,219)) ">
        <h2 class="cap-white ">You can use all of it today. It will only become better!</h2>
    </section>
</section> -->
</div>
</div>

<script src="./reveal.js/js/reveal.js "></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        width: '100%',
        height: '100%',
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {
                src: './reveal.js/lib/js/classList.js', condition: function () {
                    return !document.body.classList;
                }
            },
            {
                src: './reveal.js/plugin/markdown/marked.js', condition: function () {
                    return !!document.querySelector('[data-markdown]');
                }
            },
            {
                src: './reveal.js/plugin/markdown/markdown.js', condition: function () {
                    return !!document.querySelector('[data-markdown]');
                }
            },
            {
                src: './reveal.js/plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            },
            {src: './reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: './reveal.js/plugin/notes/notes.js', async: true}
        ]
    });
</script>
<script src="./js/main.js " type="module "></script>
</body>
</html>